//
// DRIDownloader.m
// Debian Runtime Installer - File Downloader
//

#import "DRIDownloader.h"

@interface DRIDownloader() <NSURLConnectionDelegate, NSURLConnectionDataDelegate>
@property (nonatomic, strong) NSURLConnection *connection;
@property (nonatomic, strong) NSMutableData *downloadedData;
@property (nonatomic, strong) NSString *destinationPath;
@property (nonatomic, assign) BOOL isDownloading;
@property (nonatomic, assign) double progress;
@property (nonatomic, assign) long long bytesDownloaded;
@property (nonatomic, assign) long long expectedBytes;
@end

@implementation DRIDownloader

- (instancetype)init
{
    if (self = [super init]) {
        NSLog(@"DRIDownloader: init");
        
        _isDownloading = NO;
        _progress = 0.0;
        _bytesDownloaded = 0;
        _expectedBytes = 0;
        _downloadedData = [[NSMutableData alloc] init];
    }
    return self;
}

- (void)dealloc
{
    NSLog(@"DRIDownloader: dealloc");
    [self cancelDownload];
    [_downloadedData release];
    [super dealloc];
}

- (void)downloadFileFromURL:(NSString *)urlString toPath:(NSString *)destinationPath
{
    NSLog(@"[DRIDownloader] *** downloadFileFromURL: %@ to: %@", urlString, destinationPath);
    
    if (_isDownloading) {
        NSLog(@"[DRIDownloader] *** Download already in progress, canceling previous download");
        [self cancelDownload];
    }
    
    NSURL *url = [NSURL URLWithString:urlString];
    if (!url) {
        NSLog(@"[DRIDownloader] *** ERROR: Invalid URL: %@", urlString);
        NSError *error = [NSError errorWithDomain:@"DRIDownloader" 
                                             code:1001 
                                         userInfo:@{NSLocalizedDescriptionKey: @"Invalid download URL"}];
        [self.delegate downloader:self didFailWithError:error];
        return;
    }
    
    // Ensure destination directory exists
    NSString *destinationDir = [destinationPath stringByDeletingLastPathComponent];
    NSError *dirError;
    if (![[NSFileManager defaultManager] createDirectoryAtPath:destinationDir 
                                   withIntermediateDirectories:YES 
                                                    attributes:nil 
                                                         error:&dirError]) {
        NSLog(@"[DRIDownloader] *** ERROR: Failed to create destination directory: %@", dirError.localizedDescription);
        [self.delegate downloader:self didFailWithError:dirError];
        return;
    }
    
    // Store destination path
    _destinationPath = [destinationPath copy];
    
    // Reset progress tracking
    _bytesDownloaded = 0;
    _expectedBytes = 0;
    _progress = 0.0;
    [_downloadedData setLength:0];
    
    // Create URL request
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    [request setValue:@"DebianRuntimeInstaller/1.0" forHTTPHeaderField:@"User-Agent"];
    [request setTimeoutInterval:3600.0]; // 1 hour timeout
    
    // Start connection-based download (more reliable than NSURLDownload in GNUstep)
    NSLog(@"[DRIDownloader] *** Starting NSURLConnection download");
    _connection = [[NSURLConnection alloc] initWithRequest:request delegate:self];
    
    if (_connection) {
        _isDownloading = YES;
        NSLog(@"[DRIDownloader] *** NSURLConnection started successfully");
    } else {
        NSLog(@"[DRIDownloader] *** ERROR: Failed to create NSURLConnection");
        NSError *error = [NSError errorWithDomain:@"DRIDownloader" 
                                             code:1002 
                                         userInfo:@{NSLocalizedDescriptionKey: @"Failed to create connection"}];
        [self.delegate downloader:self didFailWithError:error];
    }
    [_download setDestination:destinationPath allowOverwrite:YES];
    
    NSLog(@"DRIDownloader: started download");
}

- (void)cancelDownload
{
    if (_connection) {
        NSLog(@"[DRIDownloader] *** Canceling download");
        [_connection cancel];
        [_connection release];
        _connection = nil;
    }
    
    if (_destinationPath) {
        [_destinationPath release];
        _destinationPath = nil;
    }
    
    _isDownloading = NO;
    _progress = 0.0;
    _bytesDownloaded = 0;
    _expectedBytes = 0;
}

#pragma mark - NSURLDownload Delegate Methods

- (void)download:(NSURLDownload *)download didReceiveResponse:(NSURLResponse *)response
{
    NSLog(@"[DRIDownloader] *** didReceiveResponse called! Response: %@", response);
    _expectedBytes = [response expectedContentLength];
    NSLog(@"[DRIDownloader] *** expected length: %lld", _expectedBytes);
    
    if ([response isKindOfClass:[NSHTTPURLResponse class]]) {
        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
        NSLog(@"[DRIDownloader] *** HTTP Status: %ld", (long)[httpResponse statusCode]);
    }
    
    if (_expectedBytes > 0) {
        NSLog(@"[DRIDownloader] *** Calling delegate didStartDownloadWithExpectedSize");
        [self.delegate downloader:self didStartDownloadWithExpectedSize:_expectedBytes];
    } else {
        NSLog(@"[DRIDownloader] *** Expected size is 0 or unknown");
    }
}

- (void)download:(NSURLDownload *)download didReceiveDataOfLength:(NSUInteger)length
{
    NSLog(@"[DRIDownloader] *** didReceiveDataOfLength: %lu", (unsigned long)length);
    _bytesDownloaded += length;
    
    if (_expectedBytes > 0) {
        _progress = (double)_bytesDownloaded / (double)_expectedBytes;
    } else {
        _progress = 0.0;
    }
    
    NSLog(@"[DRIDownloader] *** progress: %.1f%% (%lld / %lld bytes)", 
          _progress * 100.0, _bytesDownloaded, _expectedBytes);
    
    if (self.delegate && [self.delegate respondsToSelector:@selector(downloader:didUpdateProgress:bytesDownloaded:)]) {
        NSLog(@"[DRIDownloader] *** Calling delegate didUpdateProgress");
        [self.delegate downloader:self didUpdateProgress:_progress bytesDownloaded:_bytesDownloaded];
    } else {
        NSLog(@"[DRIDownloader] *** ERROR: No delegate or delegate doesn't respond to didUpdateProgress");
    }
}

- (void)downloadDidFinish:(NSURLDownload *)download
{
    NSLog(@"DRIDownloader: download completed to: %@", _destinationPath);
    
    // Verify file exists and has correct size
    if ([[NSFileManager defaultManager] fileExistsAtPath:_destinationPath]) {
        NSDictionary *attributes = [[NSFileManager defaultManager] attributesOfItemAtPath:_destinationPath error:nil];
        long long fileSize = [[attributes objectForKey:NSFileSize] longLongValue];
        NSLog(@"DRIDownloader: final file size: %lld bytes", fileSize);
        
        _isDownloading = NO;
        [self.delegate downloader:self didCompleteWithFilePath:_destinationPath];
    } else {
        NSLog(@"DRIDownloader: downloaded file not found at expected location");
        _isDownloading = NO;
        NSError *error = [NSError errorWithDomain:@"DRIDownloader" 
                                             code:1002 
                                         userInfo:@{NSLocalizedDescriptionKey: @"Downloaded file not found"}];
        [self.delegate downloader:self didFailWithError:error];
    }
    
    [_download release];
    _download = nil;
    [_destinationPath release];
    _destinationPath = nil;
}

- (void)download:(NSURLDownload *)download didFailWithError:(NSError *)error
{
    NSLog(@"DRIDownloader: download failed with error: %@", error.localizedDescription);
    _isDownloading = NO;
    
    [self.delegate downloader:self didFailWithError:error];
    
    [_download release];
    _download = nil;
    [_destinationPath release];
    _destinationPath = nil;
}

@end
